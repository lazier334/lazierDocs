const swUrl=new URL(self.location.href).href.split('?').shift();const indexRequest=new Request(swUrl.replace('sw.js','index.html'));const mdFlag='${MD_TEXT}';const CACHE_NAME='lazier-docs-cache-v1';const handlerSuffixMap={'.md':processMdResponse};const cachePathSuffix={'':null,'index.html':null,'lazierDocs.js':null,'sw.js':null,};const encoder=new TextEncoder();self.addEventListener('install',(event)=>{console.log('Service Worker 安装完成');cacheResources();self.skipWaiting()});self.addEventListener('activate',(event)=>{console.log('Service Worker 激活完成');event.waitUntil(self.clients.claim())});self.addEventListener('fetch',(event)=>{const request=event.request;const url=new URL(request.url);if(url.pathname.endsWith('/clearSWCache')){console.log('清理缓存');event.respondWith(clearCacheHandler(event));return}if(url.pathname.endsWith('.md')){event.respondWith(cacheFirstHandler(event,'.md'));return}event.respondWith(cacheFirstHandler(event))});async function cacheFirstHandler(event,handlerSuffix){const request=event.request;const handler=handlerSuffixMap[handlerSuffix]||(r=>r.clone());try{let cachedResponse=null;const apiSuffix=new URL(request.url).pathname.split('/').pop();let cachePathSuffixFlag=apiSuffix in cachePathSuffix;if(cachePathSuffixFlag){cachedResponse=cachePathSuffix[apiSuffix]}if(!cachedResponse)cachedResponse=await caches.match(request);if(cachedResponse){return handler(cachedResponse)}const networkResponse=await fetch(request);if(networkResponse&&networkResponse.status===200){const cache=await caches.open(CACHE_NAME);cache.put(request,networkResponse.clone()).catch(err=>{console.warn('缓存写入失败:',err)});if(cachePathSuffixFlag){cachePathSuffix[apiSuffix]=networkResponse.clone();if(apiSuffix==''||apiSuffix=='index.html'){cache.put(indexRequest,networkResponse.clone()).catch(err=>{console.warn('缓存写入失败:',err)})}}}return handler(networkResponse)}catch(error){console.error('异常',error);const cachedResponse=await caches.match(request);if(cachedResponse){return handler(cachedResponse.clone())}return new Response('网络不可用，且无缓存内容\n'+error.messgae+'\n'+error.stack,{status:503,statusText:'Service Unavailable',headers:new Headers({'Content-Type':'text/plain; charset=utf-8'})})}}async function cacheResources(){return caches.open(CACHE_NAME).then(cache=>{return cache.addAll([swUrl.replace('sw.js','index.html'),swUrl.replace('sw.js','lazierDocs.js')])})}async function clearCacheHandler(event){try{const cacheNames=await caches.keys();await Promise.all(cacheNames.map(cacheName=>caches.delete(cacheName)));console.log('所有缓存已清理完成');cacheResources();return new Response(JSON.stringify({success:true,message:'所有缓存已清理完成'}),{status:200,headers:{'Content-Type':'application/json; charset=utf-8'}})}catch(error){console.error('清理缓存时出错:',error);return new Response(JSON.stringify({success:false,message:'清理缓存失败: '+error.message}),{status:500,headers:{'Content-Type':'application/json; charset=utf-8'}})}}async function processMdResponse(response){let resp=response.clone();try{const indexResponse=await caches.match(indexRequest);if(!indexResponse){throw new Error('暂无首页数据');}const idnexText=await(indexResponse.clone()).text();const mdText=await resp.text();const newMdContent=idnexText.replaceAll(mdFlag,encoder.encode(mdText));const modifiedResponse=new Response(newMdContent,{status:response.status,statusText:response.statusText,headers:new Headers({'Content-Type':'text/html; charset=utf-8','Content-Length':newMdContent.length.toString()})});return modifiedResponse}catch(error){console.error('处理.md文件内容时出错:',error);return resp}}